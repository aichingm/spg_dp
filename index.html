<!doctype html>
<html lang="en">
    <head>
        <title>SPG_DP</title>
        <meta charset="utf-8">
        <link rel="shortcut icon"  href="/favicon.png">
        <link rel="stylesheet" type="text/css" href="styles.css">
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/threex.transparency.js"></script>
        <script src="js/jquery-2.1.3.min.js"></script>
        <script>
            $(document).on("keypress", function (e) {
                if (e.charCode === 46) { //.
                    if ($("#settings").hasClass("isIn")) {
                        $("#settings").removeClass("isIn");
                        $("#settings").animate({
                            right: "-200px"
                        }, 200);
                    } else {
                        $("#settings").addClass("isIn");
                        $("#settings").animate({
                            right: "0px"
                        }, 200);
                    }
                }
            });</script>
        <script type="text/javascript">
            Geometries = {
                floorGemometry: function (points, z) {
                    var geometry = new THREE.Geometry();
                    if (points.length === 4) {
                        geometry.vertices.push(
                                new THREE.Vector3(points[0][0], z, points[0][1]),
                                new THREE.Vector3(points[1][0], z, points[1][1]),
                                new THREE.Vector3(points[2][0], z, points[2][1]),
                                new THREE.Vector3(points[3][0], z, points[3][1])
                                );
                        //every geometry must be built out of triangles the parameter are the points used to create the triangle
                        //a square is made out of 2 triangles remeber to keep the correct order of the points!
                        geometry.faces.push(new THREE.Face3(0, 1, 2));
                        geometry.faces.push(new THREE.Face3(0, 2, 3));
                    } else if (points.length === 3) {
                        geometry.vertices.push(
                                new THREE.Vector3(points[0][0], z, points[0][1]),
                                new THREE.Vector3(points[1][0], z, points[1][1]),
                                new THREE.Vector3(points[2][0], z, points[2][1])
                                );
                        geometry.faces.push(new THREE.Face3(0, 1, 2));
                    }
                    return geometry;
                },
                wallGemometry: function (points, z, height) {
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                            new THREE.Vector3(points[0][0], z, points[0][1]),
                            new THREE.Vector3(points[0][0], z + height, points[0][1]),
                            new THREE.Vector3(points[1][0], z + height, points[1][1]),
                            new THREE.Vector3(points[1][0], z, points[1][1])
                            );
                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                    geometry.faces.push(new THREE.Face3(0, 2, 3));
                    return geometry;
                },
                doorGemometry: function (points, z, height) {
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                            new THREE.Vector3(points[0][0], z, points[0][1]),
                            new THREE.Vector3(points[0][0], z + (height / 100 * 75), points[0][1]),
                            new THREE.Vector3(points[1][0], z + (height / 100 * 75), points[1][1]),
                            new THREE.Vector3(points[1][0], z, points[1][1])
                            );
                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                    geometry.faces.push(new THREE.Face3(0, 2, 3));
                    return geometry;
                },
                overDoorGemometry: function (points, z, height) {
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                            new THREE.Vector3(points[0][0], z + (height / 100 * 75), points[0][1]),
                            new THREE.Vector3(points[0][0], z + height, points[0][1]),
                            new THREE.Vector3(points[1][0], z + height, points[1][1]),
                            new THREE.Vector3(points[1][0], z + (height / 100 * 75), points[1][1])
                            );
                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                    geometry.faces.push(new THREE.Face3(0, 2, 3));
                    return geometry;
                },
                windowGeometry: function (points, z, height) {
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                            new THREE.Vector3(points[0][0], z + (height / 100 * 25), points[0][1]),
                            new THREE.Vector3(points[0][0], z + (height / 100 * 75), points[0][1]),
                            new THREE.Vector3(points[1][0], z + (height / 100 * 75), points[1][1]),
                            new THREE.Vector3(points[1][0], z + (height / 100 * 25), points[1][1])
                            );
                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                    geometry.faces.push(new THREE.Face3(0, 2, 3));
                    return geometry;
                },
                interfloorFloorGeometry: function (points, floors, selectedFloors) {
                    var geometry = new THREE.Geometry();
                    if (points.length === 4) {
                        if ($.inArray(points[0].floorIndex, selectedFloors) === -1 ||
                                $.inArray(points[1].floorIndex, selectedFloors) === -1 ||
                                $.inArray(points[2].floorIndex, selectedFloors) === -1 ||
                                $.inArray(points[3].floorIndex, selectedFloors) === -1) {
                            return;
                        }
                        geometry.vertices.push(
                                new THREE.Vector3(points[0].x, floors[points[0].floorIndex].offset.z, points[0].y),
                                new THREE.Vector3(points[1].x, floors[points[1].floorIndex].offset.z, points[1].y),
                                new THREE.Vector3(points[2].x, floors[points[2].floorIndex].offset.z, points[2].y),
                                new THREE.Vector3(points[3].x, floors[points[3].floorIndex].offset.z, points[3].y)
                                );
                        //every geometry must be built out of triangles the parameter are the points used to create the triangle
                        //a square is made out of 2 triangles remeber to keep the correct order of the points!
                        geometry.faces.push(new THREE.Face3(0, 1, 2));
                        geometry.faces.push(new THREE.Face3(0, 2, 3));
                    } else if (points.length === 3) {
                        if ($.inArray(points[0].floorIndex, selectedFloors) === -1 ||
                                $.inArray(points[1].floorIndex, selectedFloors) === -1 ||
                                $.inArray(points[2].floorIndex, selectedFloors) === -1) {
                            return;
                        }
                        geometry.vertices.push(
                                new THREE.Vector3(points[0].x, floors[points[0].floorIndex].offset.z, points[0][1]),
                                new THREE.Vector3(points[1].x, floors[points[1].floorIndex].offset.z, points[1][1]),
                                new THREE.Vector3(points[2].x, floors[points[2].floorIndex].offset.z, points[2][1])
                                );
                        geometry.faces.push(new THREE.Face3(0, 1, 2));
                    }
                    return geometry;
                },
                interfloorWallGeometry: function (points, floors, selectedFloors) {
                    if ($.inArray(points[0].floorIndex, selectedFloors) === -1 ||
                            $.inArray(points[1].floorIndex, selectedFloors) === -1) {
                        return;
                    }
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                            new THREE.Vector3(points[0].x, floors[points[0].floorIndex].offset.z, points[0].y),
                            new THREE.Vector3(points[0].x, floors[points[0].floorIndex].offset.z + floors[points[0].floorIndex].height, points[0].y),
                            new THREE.Vector3(points[1].x, floors[points[1].floorIndex].offset.z + floors[points[1].floorIndex].height, points[1].y),
                            new THREE.Vector3(points[1].x, floors[points[1].floorIndex].offset.z, points[1].y)
                            );
                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                    geometry.faces.push(new THREE.Face3(0, 2, 3));
                    return geometry;
                },
                edgeGeometry: function (pointX, pointY, geometryOptions, material) {
                    var direction = new THREE.Vector3().subVectors(pointY, pointX);
                    var arrow = new THREE.ArrowHelper(direction, pointX);
                    var edgeGeometry = new THREE.CylinderGeometry(
                            geometryOptions.radiusAtTop,
                            geometryOptions.radiusAtBottom,
                            direction.length(),
                            geometryOptions.radiusSegments,
                            geometryOptions.heightSegments);
                    var edge = new THREE.Mesh(edgeGeometry, material);
                    edge.rotation.x = arrow.rotation.x;
                    edge.rotation.y = arrow.rotation.y;
                    edge.rotation.z = arrow.rotation.z;
                    var finalPosition = new THREE.Vector3().addVectors(pointX, direction.multiplyScalar(0.5));
                    edge.position.x = finalPosition.x;
                    edge.position.y = finalPosition.y;
                    edge.position.z = finalPosition.z;
                    return edge;
                }
            };</script>
        <script>
            // JsHint directives
            /* global THREE */
            /* global THREEx */
            /* global Storage */
            var updateFcts = [];
            var scene, camera, renderer;
            function clearScene() {
                var obj, i;
                for (i = scene.children.length - 1; i >= 0; i--) {
                    obj = scene.children[ i ];
                    if (obj !== camera) {
                        scene.remove(obj);
                    }
                }
            }

            var windowMaterial = new THREE.MeshBasicMaterial({
                color: 0x0030ee,
                opacity: 0.5,
                transparent: true,
                side: THREE.DoubleSide
            });
            var wallMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                opacity: 0.5,
                transparent: true,
                side: THREE.DoubleSide
            });
            var doorMaterial = new THREE.MeshBasicMaterial({
                color: 0xee00ee,
                opacity: 0.5,
                transparent: true,
                side: THREE.DoubleSide
            });
            var floorMaterial = new THREE.MeshBasicMaterial({
                color: 0x555555,
                transparent: false,
                side: THREE.DoubleSide
            });
            // Set up the scene, camera, and renderer as global variables.
            init();
            animate();
            // Sets up the scene.
            function init() {
                // Create the scene and set the scene size.
                scene = new THREE.Scene();
                var WIDTH = window.innerWidth,
                        HEIGHT = window.innerHeight;
                // Create a renderer and add it to the DOM.
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(WIDTH, HEIGHT);
                document.body.appendChild(renderer.domElement);
                // Create a camera, zoom it out from the model a bit, and add it to the scene.
                camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT, 0.1, 2000000000);
                camera.position.set(1000, 1000, 1000);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                scene.add(camera);
                // Create an event listener that resizes the renderer with the browser window.
                window.addEventListener('resize', function () {
                    var WIDTH = window.innerWidth,
                            HEIGHT = window.innerHeight;
                    renderer.setSize(WIDTH, HEIGHT);
                    camera.aspect = WIDTH / HEIGHT;
                    camera.updateProjectionMatrix();
                });
                // Set the background color of the scene.
                //renderer.setClearColorHex(0x333F47, 1);
                renderer.setClearColor(0x333F47, 1);
                // Create a light, set its position, and add it to the scene.
                //var light = new THREE.PointLight(0xffffff, 1000, 0);
                //light.position.set(-1000, 2000, 1000);
                //scene.add(light);
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.userPanSpeed = 15;
            }


            // Renders the scene and updates the render as needed.
            function animate() {
                requestAnimationFrame(animate);
                // Render the scene.
                renderer.render(scene, camera);
                controls.update();
                updateFcts.forEach(function (updateFn) {
                    updateFn();
                });
            }




            function draw(data, clear) {

                var selectedFloors = [];
                if ($("#drawFloors").val()) {
                    $.each($("#drawFloors").val(), function (v, k) {
                        selectedFloors.push(parseInt(k));
                    });
                }
                if (clear === true) {
                    clearScene();
                }
                var objects = {};
                objects.floors = [];
                objects.walls = [];
                objects.windows = [];
                objects.doors = [];
                objects.interfloorWalls = [];
                objects.interfloorFloors = [];
                objects.pathPoints = [];
                objects.edges = [];

                $(data.modelManager.floors).each(function (k) {
                    if ($.inArray(k, selectedFloors) === -1) {
                        return;
                    }
                    $(this.elements).each(function (floor) {
                        return function () {
                            switch (this.type) {
                                case "floor":
                                    var geometry = Geometries.floorGemometry(this.points, floor.offset.z);
                                    geometry.computeBoundingSphere();
                                    var mesh = new THREE.Mesh(geometry, floorMaterial);
                                    objects.floors.push(mesh);
                                    break;
                                case "wall":
                                    var geometry = Geometries.wallGemometry(this.points, floor.offset.z, floor.height);
                                    geometry.computeBoundingSphere();
                                    var mesh = new THREE.Mesh(geometry, wallMaterial);
                                    objects.walls.push(mesh);
                                    break;
                                case "door":
                                    var geometryDoor = Geometries.doorGemometry(this.points, floor.offset.z, floor.height);
                                    geometryDoor.computeBoundingSphere();
                                    var meshDoor = new THREE.Mesh(geometryDoor, doorMaterial);
                                    objects.doors.push(meshDoor);
                                    var geometryOverDoor = Geometries.overDoorGemometry(this.points, floor.offset.z, floor.height);
                                    geometryOverDoor.computeBoundingSphere();
                                    var meshOverDoor = new THREE.Mesh(geometryOverDoor, wallMaterial);
                                    objects.doors.push(meshOverDoor);
                                    break;
                                case "window":
                                    var geometryWindow = Geometries.windowGeometry(this.points, floor.offset.z, floor.height);
                                    geometryWindow.computeBoundingSphere();
                                    var meshWindow = new THREE.Mesh(geometryWindow, windowMaterial);
                                    objects.windows.push(meshWindow);
                                    break;
                            }
                        };
                    }(this));
                });

                $(data.interFloorObjects).each(function (data) {
                    return function (i, object) {
                        var floors = data.modelManager.floors;
                        switch (object.type) {
                            case "floor":
                                var geometry = Geometries.interfloorFloorGeometry(object.points, floors, selectedFloors);
                                if (geometry) {
                                    geometry.computeBoundingSphere();
                                    var mesh = new THREE.Mesh(geometry, floorMaterial);
                                    objects.interfloorFloors.push(mesh);
                                }
                                break;
                            case "wall":
                                var geometry = Geometries.interfloorWallGeometry(object.points, floors, selectedFloors);
                                if (geometry) {
                                    geometry.computeBoundingSphere();
                                    var mesh = new THREE.Mesh(geometry, wallMaterial);
                                    objects.interfloorWalls.push(mesh);
                                }
                                break;
                        }
                    };
                }(data));

                $(data.paths.vertices).each(function (data) {
                    return function (i, object) {
                        if ($.inArray(object.floorIndex, selectedFloors) === -1) {
                            return;
                        }
                        var floors = data.modelManager.floors;
                        console.log(object);
                        var geometry = new THREE.SphereGeometry(50, 32, 32);
                        var material = new THREE.MeshBasicMaterial({color: 0xffff00});
                        var sphere = new THREE.Mesh(geometry, material);
                        sphere.position.x = object.x;
                        sphere.position.z = object.y;
                        sphere.position.y = floors[object.floorIndex].offset.z + 70;
                        objects.pathPoints.push(sphere);
                    };
                }(data));

                $(data.paths.edges).each(function (data) {
                    return function (i, object) {
                        if ($.inArray(object.Afloor, selectedFloors) === -1 ||
                                $.inArray(object.Bfloor, selectedFloors) === -1) {
                            return;
                        }
                        var floors = data.modelManager.floors;
                        var material = new THREE.MeshBasicMaterial({color: 0x0000ff});
                        var edge = Geometries.edgeGeometry(
                                new THREE.Vector3(object.Ax, floors[object.Afloor].offset.z + 70, object.Ay),
                                new THREE.Vector3(object.Bx, floors[object.Bfloor].offset.z + 70, object.By),
                                {"radiusAtTop": 10, "radiusAtBottom": 10, "radiusSegments": 6, "heightSegments": 4},
                        material
                                );
                        objects.edges.push(edge);
                    };
                }(data)
                        );
                $.each(objects.floors, function () {
                    scene.add(this);
                });
                $.each(objects.interfloorFloors, function () {
                    scene.add(this);
                });
                $.each(objects.walls, function () {
                    scene.add(this);
                });
                $.each(objects.pathPoints, function () {
                    scene.add(this);
                });
                $.each(objects.edges, function () {
                    scene.add(this);
                });
                THREEx.Transparency.init(objects.walls);
                $.each(objects.doors, function () {
                    scene.add(this);
                });
                THREEx.Transparency.init(objects.doors);
                $.each(objects.windows, function () {
                    scene.add(this);
                });
                THREEx.Transparency.init(objects.interfloorWalls);
                $.each(objects.interfloorFloors, function () {
                    scene.add(this);
                });
                THREEx.Transparency.init(objects.windows);
                updateFcts.push(function (delta, now) {
                    THREEx.Transparency.update(objects.walls, camera);
                    THREEx.Transparency.update(objects.windows, camera);
                    THREEx.Transparency.update(objects.doors, camera);
                    THREEx.Transparency.update(objects.interfloorWalls, camera);
                });

            }
            function buildShowDiv() {
                if (typeof (Storage) !== "undefined") {
                    var exports = localStorage.getItem("PieceofShit.exports");
                    //check if they are valid
                    if (exports !== null && exports !== undefined && exports.length > 0) {
                        //draw them
                        var data = JSON.parse(exports);
                        $("#drawFloors").html("");
                        $(data.modelManager.floors).each(function (k) {
                            $("#drawFloors").append("<option selected='selected' value='" + k + "'>" + this.name + "</option>");
                        });
                        $("#drawFloors").attr("size", data.modelManager.floors.length);
                    }
                    $("#drawFloors").change(function (e) {
                        if (typeof (Storage) !== "undefined") {
                            var exports = localStorage.getItem("PieceofShit.exports");
                            //check if they are valid
                            if (exports !== null && exports !== undefined && exports.length > 0) {
                                //draw them
                                draw(JSON.parse(exports), true);
                            }
                        }
                    });
                }
            }
            $(document).ready(function () {
                $(window).bind('storage', function (e) {
                    if (e.originalEvent.key === "PieceofShit.exports") {
                        buildShowDiv();
                        draw(JSON.parse(e.originalEvent.newValue), true);
                    }
                });
                //check if exportObjects are cached and if load them
                if (typeof (Storage) !== "undefined") {
                    var exports = localStorage.getItem("PieceofShit.exports");
                    //check if they are valid
                    if (exports !== null && exports !== undefined && exports.length > 0) {
                        //draw them
                        buildShowDiv();
                        draw(JSON.parse(exports), false);
                    }
                }
            });
        </script>
        <div id="settings">
            <div class="settingsLine settingsLineH1">
                Settings
            </div>
            <div class="settingsLine">
                Draw Floors<br>
                <select multiple="" id="drawFloors">
                </select>
            </div>
        </div>
    </body>
</html>
