<!doctype html>
<html lang="en">
    <head>
        <title>SPG_DP</title>
        <meta charset="utf-8">
        <link rel="shortcut icon"  href="/favicon.png">
        <link rel="stylesheet" type="text/css" href="styles.css">
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
        <script>
            $(document).on("keypress", function (e) {
                if (e.charCode === 46) { //.
                    if ($("#settings").hasClass("isIn")) {
                        $("#settings").removeClass("isIn");
                        $("#settings").animate({
                            right: "-200px"
                        }, 200);
                    } else {
                        $("#settings").addClass("isIn");
                        $("#settings").animate({
                            right: "0px"
                        }, 200);
                    }
                }
            });
        </script>
        <script>
            // JsHint directives
            /* global THREE */

            var scene, camera, renderer;

            function mmm_clear() {
                var obj, i;
                for (i = scene.children.length - 1; i >= 0; i--) {
                    obj = scene.children[ i ];
                    if (obj !== camera) {
                        scene.remove(obj);
                    }
                }
            }
            // Set up the scene, camera, and renderer as global variables.
            init();
            animate();



            // Sets up the scene.
            function init() {
                // Create the scene and set the scene size.
                scene = new THREE.Scene();
                var WIDTH = window.innerWidth,
                        HEIGHT = window.innerHeight;
                // Create a renderer and add it to the DOM.
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(WIDTH, HEIGHT);
                document.body.appendChild(renderer.domElement);
                // Create a camera, zoom it out from the model a bit, and add it to the scene.
                camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT, 0.1, 2000000000);
                camera.position.set(1000, 1000, 1000);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                scene.add(camera);
                // Create an event listener that resizes the renderer with the browser window.
                window.addEventListener('resize', function () {
                    var WIDTH = window.innerWidth,
                            HEIGHT = window.innerHeight;
                    renderer.setSize(WIDTH, HEIGHT);
                    camera.aspect = WIDTH / HEIGHT;
                    camera.updateProjectionMatrix();
                });
                // Set the background color of the scene.
                //renderer.setClearColorHex(0x333F47, 1);
                renderer.setClearColor(0x333F47, 1);
                // Create a light, set its position, and add it to the scene.
                //var light = new THREE.PointLight(0xffffff, 1000, 0);
                //light.position.set(-1000, 2000, 1000);
                //scene.add(light);
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.userPanSpeed = 15;
            }


            // Renders the scene and updates the render as needed.
            function animate() {
                requestAnimationFrame(animate);
                // Render the scene.
                renderer.render(scene, camera);
                controls.update();
            }

            function draw(data, clear) {

                var selectedFloors = [];
                if ($("#drawFloors").val()) {
                    $.each($("#drawFloors").val(), function (v, k) {
                        selectedFloors.push(parseInt(k));
                    });
                }
                console.log(selectedFloors, data);
                if (clear === true) {
                    mmm_clear();
                }

                $(data.modelManager).each(function () {
                    $(this.floors).each(function (k) {
                        //console.log(this);
                        if ($.inArray(k, selectedFloors) === -1) {
                            return;
                        }
                        $(this.elements).each(function (floor) {
                            return function () {
                                //console.log(floor);
                                //console.log(this);
                                switch (this.type) {
                                    case "floor":
                                        var geometry = new THREE.Geometry();
                                        if (this.points.length === 4) {
                                            geometry.vertices.push(
                                                    new THREE.Vector3(this.points[0][0], floor.offset.z, this.points[0][1]),
                                                    new THREE.Vector3(this.points[1][0], floor.offset.z, this.points[1][1]),
                                                    new THREE.Vector3(this.points[2][0], floor.offset.z, this.points[2][1]),
                                                    new THREE.Vector3(this.points[3][0], floor.offset.z, this.points[3][1])
                                                    );
                                            //every geometry must be built out of triangles the parameter are the points used to create the triangle
                                            //a square is made out of 2 triangles remeber to keep the correct order of the points!
                                            geometry.faces.push(new THREE.Face3(0, 1, 2));
                                            geometry.faces.push(new THREE.Face3(0, 2, 3));
                                        } else if (this.points.length === 3) {
                                            geometry.vertices.push(
                                                    new THREE.Vector3(this.points[0][0], floor.offset.z, this.points[0][1]),
                                                    new THREE.Vector3(this.points[1][0], floor.offset.z, this.points[1][1]),
                                                    new THREE.Vector3(this.points[2][0], floor.offset.z, this.points[2][1])
                                                    );
                                            geometry.faces.push(new THREE.Face3(0, 1, 2));
                                        }
                                        geometry.computeBoundingSphere();
                                        var material = new THREE.MeshBasicMaterial({
                                            color: 0x555555,
                                            side: THREE.DoubleSide
                                        });
                                        var mesh = new THREE.Mesh(geometry, material);
                                        scene.add(mesh);
                                        break;
                                    case "wall":
                                        //console.log("it's a wall");
                                        var geometry = new THREE.Geometry();
                                        geometry.vertices.push(
                                                new THREE.Vector3(this.points[0][0], floor.offset.z, this.points[0][1]),
                                                new THREE.Vector3(this.points[0][0], floor.offset.z + floor.height, this.points[0][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z + floor.height, this.points[1][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z, this.points[1][1])
                                                );
                                        //console.log(floor);
                                        geometry.faces.push(new THREE.Face3(0, 1, 2));
                                        geometry.faces.push(new THREE.Face3(0, 2, 3));

                                        geometry.computeBoundingSphere();
                                        var material = new THREE.MeshBasicMaterial({
                                            color: 0xaaaaaa,
                                            opacity: 0.5,
                                            //color: "black",
                                            transparent: true,
                                            side: THREE.DoubleSide,
                                            depthWrite: false, //http://stackoverflow.com/questions/11165345/three-js-webgl-transparent-planes-hiding-other-planes-behind-them
                                            depthTest: false, //http://stackoverflow.com/questions/11165345/three-js-webgl-transparent-planes-hiding-other-planes-behind-them
                                            blending: THREE.SubtractiveBlending
                                        });
                                        //mesh.material.side = THREE.DoubleSide;

                                        var mesh = new THREE.Mesh(geometry, material);
                                        mesh.renderDepth = 100000;
                                        scene.add(mesh);
                                        break;
                                    case "door":
                                        //console.log("it's a door");
                                        var geometryDoor = new THREE.Geometry();
                                        geometryDoor.vertices.push(
                                                new THREE.Vector3(this.points[0][0], floor.offset.z, this.points[0][1]),
                                                new THREE.Vector3(this.points[0][0], floor.offset.z + (floor.height / 100 * 75), this.points[0][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z + (floor.height / 100 * 75), this.points[1][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z, this.points[1][1])
                                                );
                                        geometryDoor.faces.push(new THREE.Face3(0, 1, 2));
                                        geometryDoor.faces.push(new THREE.Face3(0, 2, 3));
                                        geometryDoor.computeBoundingSphere();
                                        var materialDoor = new THREE.MeshBasicMaterial({
                                            color: 0xee00ee,
                                            opacity: 0.5,
                                            transparent: true,
                                            side: THREE.DoubleSide,
                                            blending: THREE.SubtractiveBlending,
                                            depthWrite: false,
                                            depthTest: false
                                        });
                                        var meshDoor = new THREE.Mesh(geometryDoor, materialDoor);
                                        scene.add(meshDoor);

                                        var geometryOverDoor = new THREE.Geometry();
                                        geometryOverDoor.vertices.push(
                                                new THREE.Vector3(this.points[0][0], floor.offset.z + (floor.height / 100 * 75), this.points[0][1]),
                                                new THREE.Vector3(this.points[0][0], floor.offset.z + floor.height, this.points[0][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z + floor.height, this.points[1][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z + (floor.height / 100 * 75), this.points[1][1])
                                                );
                                        geometryOverDoor.faces.push(new THREE.Face3(0, 1, 2));
                                        geometryOverDoor.faces.push(new THREE.Face3(0, 2, 3));
                                        geometryOverDoor.computeBoundingSphere();
                                        var materialOverDoor = new THREE.MeshBasicMaterial({
                                            color: 0xaaaaaa,
                                            opacity: 0.5,
                                            transparent: true,
                                            side: THREE.DoubleSide,
                                            depthWrite: false,
                                            depthTest: false,
                                            blending: THREE.SubtractiveBlending
                                        });
                                        var meshOverDoor = new THREE.Mesh(geometryOverDoor, materialOverDoor);
                                        scene.add(meshOverDoor);
                                        break;
                                    case "window":
                                        //console.log("it's a window");
                                        var geometryWindow = new THREE.Geometry();
                                        geometryWindow.vertices.push(
                                                new THREE.Vector3(this.points[0][0], floor.offset.z + (floor.height / 100 * 25), this.points[0][1]),
                                                new THREE.Vector3(this.points[0][0], floor.offset.z + (floor.height / 100 * 75), this.points[0][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z + (floor.height / 100 * 75), this.points[1][1]),
                                                new THREE.Vector3(this.points[1][0], floor.offset.z + (floor.height / 100 * 25), this.points[1][1])
                                                );
                                        geometryWindow.faces.push(new THREE.Face3(0, 1, 2));
                                        geometryWindow.faces.push(new THREE.Face3(0, 2, 3));
                                        geometryWindow.computeBoundingSphere();
                                        var materialWindow = new THREE.MeshBasicMaterial({
                                            color: 0x0030ee,
                                            opacity: 0.5,
                                            transparent: true,
                                            side: THREE.DoubleSide,
                                            depthWrite: false,
                                            depthTest: false,
                                            blending: THREE.SubtractiveBlending
                                        });
                                        var meshWindow = new THREE.Mesh(geometryWindow, materialWindow);
                                        scene.add(meshWindow);
                                        break;
                                }
                            };

                        }(this));

                    });
                });
                //console.log("inter floor objects");
                $(data.interFloorObjects).each(function (data) {
                    return function (i, object) {

                        var floors = data.modelManager.floors;
                        switch (object.type) {
                            case "floor":
                                var geometry = new THREE.Geometry();
                                if (this.points.length === 4) {
                                    if ($.inArray(object.points[0].floorIndex, selectedFloors) === -1 ||
                                            $.inArray(object.points[1].floorIndex, selectedFloors) === -1 ||
                                            $.inArray(object.points[2].floorIndex, selectedFloors) === -1 ||
                                            $.inArray(object.points[3].floorIndex, selectedFloors) === -1) {
                                        return;
                                    }
                                    geometry.vertices.push(
                                            new THREE.Vector3(object.points[0].x, floors[object.points[0].floorIndex].offset.z, object.points[0].y),
                                            new THREE.Vector3(object.points[1].x, floors[object.points[1].floorIndex].offset.z, object.points[1].y),
                                            new THREE.Vector3(object.points[2].x, floors[object.points[2].floorIndex].offset.z, object.points[2].y),
                                            new THREE.Vector3(object.points[3].x, floors[object.points[3].floorIndex].offset.z, object.points[3].y)
                                            );
                                    //every geometry must be built out of triangles the parameter are the points used to create the triangle
                                    //a square is made out of 2 triangles remeber to keep the correct order of the points!
                                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                                    geometry.faces.push(new THREE.Face3(0, 2, 3));
                                } else if (this.points.length === 3) {
                                    if ($.inArray(object.points[0].floorIndex, selectedFloors) === -1 ||
                                            $.inArray(object.points[1].floorIndex, selectedFloors) === -1 ||
                                            $.inArray(object.points[2].floorIndex, selectedFloors) === -1) {
                                        return;
                                    }
                                    geometry.vertices.push(
                                            new THREE.Vector3(object.points[0].x, floors[object.points[0].floorIndex].offset.z, object.points[0][1]),
                                            new THREE.Vector3(object.points[1].x, floors[object.points[1].floorIndex].offset.z, object.points[1][1]),
                                            new THREE.Vector3(object.points[2].x, floors[object.points[2].floorIndex].offset.z, object.points[2][1])
                                            );
                                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                                }
                                geometry.computeBoundingSphere();
                                var material = new THREE.MeshBasicMaterial({
                                    color: 0x555555,
                                    side: THREE.DoubleSide,
                                    depthWrite: false,
                                    depthTest: false
                                });
                                var mesh = new THREE.Mesh(geometry, material);
                                scene.add(mesh);
                                break;
                            case "wall":
                                if ($.inArray(object.points[0].floorIndex, selectedFloors) === -1 ||
                                        $.inArray(object.points[1].floorIndex, selectedFloors) === -1) {
                                    return;
                                }
                                //console.log("it's a wall");
                                var geometry = new THREE.Geometry();
                                geometry.vertices.push(
                                        new THREE.Vector3(this.points[0].x, floors[object.points[0].floorIndex].offset.z, this.points[0].y),
                                        new THREE.Vector3(this.points[0].x, floors[object.points[0].floorIndex].offset.z + floors[object.points[0].floorIndex].height, this.points[0].y),
                                        new THREE.Vector3(this.points[1].x, floors[object.points[1].floorIndex].offset.z + floors[object.points[1].floorIndex].height, this.points[1].y),
                                        new THREE.Vector3(this.points[1].x, floors[object.points[1].floorIndex].offset.z, this.points[1].y)
                                        );
                                geometry.faces.push(new THREE.Face3(0, 1, 2));
                                geometry.faces.push(new THREE.Face3(0, 2, 3));

                                geometry.computeBoundingSphere();
                                var material = new THREE.MeshBasicMaterial({
                                    color: 0xaaaaaa,
                                    opacity: 0.5,
                                    transparent: true,
                                    side: THREE.DoubleSide,
                                    depthWrite: false,
                                    depthTest: false,
                                    blending: THREE.SubtractiveBlending
                                });
                                var mesh = new THREE.Mesh(geometry, material);
                                scene.add(mesh);
                                break;
                        }
                    };
                }(data));

            }
            function buildShowDiv() {
                if (typeof (Storage) !== "undefined") {
                    var exports = localStorage.getItem("PieceofShit.exports");
                    //check if they are valid
                    if (exports !== null && exports !== undefined && exports.length > 0) {
                        //draw them
                        var data = JSON.parse(exports);
                        $("#drawFloors").html("");
                        $(data.modelManager.floors).each(function (k) {
                            $("#drawFloors").append("<option selected='selected' value='" + k + "'>" + this.name + "</option>");
                        });
                        $("#drawFloors").attr("size", data.modelManager.floors.length);
                    }
                    $("#drawFloors").change(function (e) {
                        if (typeof (Storage) !== "undefined") {
                            var exports = localStorage.getItem("PieceofShit.exports");
                            //check if they are valid
                            if (exports !== null && exports !== undefined && exports.length > 0) {
                                //draw them
                                draw(JSON.parse(exports), true);
                            }
                        }
                    });
                }
            }
            $(document).ready(function () {
                $(window).bind('storage', function (e) {
                    if (e.originalEvent.key === "PieceofShit.exports") {
                        buildShowDiv();
                        draw(JSON.parse(e.originalEvent.newValue), true);
                    }
                });

                //check if exportObjects are cached and if load them
                if (typeof (Storage) !== "undefined") {
                    var exports = localStorage.getItem("PieceofShit.exports");
                    //check if they are valid
                    if (exports !== null && exports !== undefined && exports.length > 0) {
                        //draw them
                        buildShowDiv();
                        draw(JSON.parse(exports), false);

                    }
                }
            });
        </script>
        <div id="settings">
            <div class="settingsLine settingsLineH1">
                Settings
            </div>
            <div class="settingsLine">
                Draw Floors<br>
                <select multiple="" id="drawFloors">
                </select>
            </div>
        </div>
    </body>
</html>
